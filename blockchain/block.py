"""
Block class for Sociora blockchain.
Implements Proof of Transcoding/Storage consensus with multi-beneficiary reward distribution.
"""

from dataclasses import dataclass, asdict, field
from typing import List, Dict, Optional, Any
from enum import Enum
from utils import CryptoUtils, TokenomicsUtils
from transaction import Transaction, TransactionType


class ConsensusMechanism(Enum):
    """Consensus types for Sociora blockchain."""
    PROOF_OF_TRANSCODING = "PROOF_OF_TRANSCODING"  # Primary consensus
    PROOF_OF_STORAGE = "PROOF_OF_STORAGE"  # Secondary consensus
    PROOF_OF_ATTENTION = "PROOF_OF_ATTENTION"  # Viewer engagement


@dataclass
class Beneficiary:
    """
    Represents a beneficiary in reward distribution.
    
    Attributes:
        address: Hashed public key of beneficiary
        role: Role type (creator, miner, viewer, platform)
        percentage: Share of reward (0-100)
        amount: Calculated reward amount (coins)
    """
    address: str  # Hashed public key
    role: str  # "creator", "miner", "viewer", "platform"
    percentage: float  # 0-100
    amount: Optional[float] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            'address': self.address,
            'role': self.role,
            'percentage': self.percentage,
            'amount': self.amount
        }


@dataclass
class BlockReward:
    """
    Reward generated by block mining.
    Handles automatic distribution to multiple beneficiaries.
    
    Attributes:
        base_reward: Coins minted for this block (block subsidy)
        fee_reward: Transaction fees collected in block
        total_reward: base_reward + fee_reward
        beneficiaries: List of reward recipients
        distribution: Dict mapping address -> amount
        consensus_type: Mechanism used to mine this block
    """
    base_reward: float
    fee_reward: float
    beneficiaries: List[Beneficiary]
    consensus_type: ConsensusMechanism = ConsensusMechanism.PROOF_OF_TRANSCODING
    
    # Computed fields
    total_reward: Optional[float] = None
    distribution: Dict[str, float] = field(default_factory=dict)

    def __post_init__(self):
        """Compute total reward and validate beneficiaries."""
        self.total_reward = self.base_reward + self.fee_reward
        self._validate_beneficiaries()

    def _validate_beneficiaries(self):
        """Ensure beneficiaries' percentages sum to 100."""
        total_percent = sum(b.percentage for b in self.beneficiaries)
        if abs(total_percent - 100.0) > 0.01:
            raise ValueError(
                f"Beneficiary percentages must sum to 100. Got {total_percent}"
            )

    def calculate_distribution(self) -> Dict[str, float]:
        """
        Calculate reward distribution using tokenomics rules.
        
        Verifies that:
        1. Total percentages = 100
        2. All addresses are valid hashes
        3. Amounts are properly rounded
        
        Returns:
            Dict mapping (role -> address) to amount
            
        Example:
            {
                'creator|Qm...': 40.0,
                'miner|Qm...': 35.0,
                'viewer|Qm...': 15.0,
                'platform|Qm...': 10.0
            }
        """
        self.distribution = {}
        
        for beneficiary in self.beneficiaries:
            share = self.total_reward * (beneficiary.percentage / 100)
            beneficiary.amount = round(share, 8)  # 8 decimal places for coins
            
            # Create composite key (role + address) for clarity
            key = f"{beneficiary.role}|{beneficiary.address[:16]}..."
            self.distribution[key] = beneficiary.amount
        
        return self.distribution

    def validate_distribution(self) -> bool:
        """
        Verify that total distributed equals total reward (account for rounding).
        
        Returns:
            True if distribution is valid
        """
        if not self.distribution:
            self.calculate_distribution()
        
        total_distributed = sum(self.distribution.values())
        # Allow small rounding error
        return abs(total_distributed - self.total_reward) <= 0.01

    def to_dict(self) -> Dict[str, Any]:
        """Convert block reward to dictionary."""
        if not self.distribution:
            self.calculate_distribution()
        
        return {
            'base_reward': self.base_reward,
            'fee_reward': self.fee_reward,
            'total_reward': self.total_reward,
            'consensus_type': self.consensus_type.value,
            'beneficiaries': [b.to_dict() for b in self.beneficiaries],
            'distribution': self.distribution
        }


@dataclass
class Block:
    """
    Production-grade block for Sociora blockchain.
    
    Implements Proof of Transcoding/Storage consensus where:
    - Miners validate video storage and transcoding
    - Reward is split among Creator, Miner, Viewer, Platform
    
    Attributes:
        block_number: Height of block in chain
        timestamp: ISO 8601 timestamp of block creation
        miner_address: Hashed public key of mining validator
        previous_hash: Hash of parent block (0^256 for genesis)
        
        transactions: List of validated transactions in block
        transaction_hashes: Merkle tree root of transactions
        
        video_proofs: List of (video_hash, miner_signature) storage proofs
        proof_of_work: Nonce or proof satisfying consensus rules
        
        block_reward: Multi-beneficiary reward distribution
        difficulty: Current difficulty target
        nonce: Proof-of-Transcoding nonce
        
        metadata: Additional block metadata
    """
    
    block_number: int
    timestamp: str
    miner_address: str  # Hashed public key
    previous_hash: str  # Parent block hash (0x00... for genesis)
    
    transactions: List[Transaction]
    transaction_hashes: List[str] = field(default_factory=list)
    
    # Proof of Storage/Transcoding
    video_proofs: List[Dict[str, str]] = field(default_factory=list)
    proof_of_work: str = ""  # Nonce or proof bytes
    
    # Reward generation
    block_reward: Optional[BlockReward] = None
    difficulty: int = 1  # Difficulty target
    nonce: int = 0
    
    # Metadata
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    # Computed field
    _block_hash: Optional[str] = None

    def __post_init__(self):
        """Initialize block fields."""
        if not self.transaction_hashes and self.transactions:
            self.transaction_hashes = [tx.tx_hash for tx in self.transactions]

    def compute_block_hash(self) -> str:
        """
        Compute immutable block hash using SHA-256.
        Hash includes all data except the hash itself.
        
        Returns:
            SHA-256 hash of block header
        """
        block_dict = {
            'block_number': self.block_number,
            'timestamp': self.timestamp,
            'miner_address': self.miner_address,
            'previous_hash': self.previous_hash,
            'transaction_hashes': self.transaction_hashes,
            'proof_of_work': self.proof_of_work,
            'difficulty': self.difficulty,
            'nonce': self.nonce
        }
        self._block_hash = CryptoUtils.generate_block_hash(block_dict)
        return self._block_hash

    @property
    def block_hash(self) -> str:
        """Get block hash, computing if necessary."""
        if self._block_hash is None:
            self.compute_block_hash()
        return self._block_hash

    def generate_reward(
        self,
        base_subsidy: float,
        creator_address: str,
        creator_percentage: float,
        miner_percentage: float,
        viewer_percentage: float,
        platform_percentage: float,
        viewer_address: Optional[str] = None,
        platform_address: Optional[str] = None
    ) -> BlockReward:
        """
        Generate and distribute block reward to multiple beneficiaries.
        
        This is the CORE of Sociora tokenomics:
        - Creator: Receives share for owning the video
        - Miner: Receives share for validating storage/transcoding
        - Viewer: Receives share for proof-of-attention
        - Platform: Receives share for transaction fees and infrastructure
        
        Args:
            base_subsidy: Coins minted for this block
            creator_address: Hashed public key of video creator
            creator_percentage: Creator's share (typically 40%)
            miner_percentage: Miner's share (typically 35%)
            viewer_percentage: Viewer's share (typically 15%)
            platform_percentage: Platform's share (typically 10%)
            viewer_address: Optional hashed key of viewer (or aggregate)
            platform_address: Optional hashed key of platform wallet
            
        Returns:
            BlockReward object with calculated distribution
            
        Raises:
            ValueError: If percentages don't sum to 100
        """
        
        # Collect transaction fees
        fee_reward = sum(
            tx.gas_limit * tx.gas_price 
            for tx in self.transactions
        )
        
        # Use miner address as default viewer if not provided
        if viewer_address is None:
            viewer_address = self.miner_address
        
        # Use standard platform address if not provided
        if platform_address is None:
            platform_address = "0000000000000000000000000000000000000000000000000000000000000001"
        
        # Create beneficiary list
        beneficiaries = [
            Beneficiary(
                address=creator_address,
                role="creator",
                percentage=creator_percentage
            ),
            Beneficiary(
                address=self.miner_address,
                role="miner",
                percentage=miner_percentage
            ),
            Beneficiary(
                address=viewer_address,
                role="viewer",
                percentage=viewer_percentage
            ),
            Beneficiary(
                address=platform_address,
                role="platform",
                percentage=platform_percentage
            )
        ]
        
        # Create and validate reward
        self.block_reward = BlockReward(
            base_reward=base_subsidy,
            fee_reward=fee_reward,
            beneficiaries=beneficiaries,
            consensus_type=ConsensusMechanism.PROOF_OF_TRANSCODING
        )
        
        # Calculate distribution
        self.block_reward.calculate_distribution()
        
        if not self.block_reward.validate_distribution():
            raise ValueError("Reward distribution failed validation")
        
        return self.block_reward

    def add_transaction(self, transaction: Transaction) -> None:
        """
        Add validated transaction to block.
        
        Args:
            transaction: Validated Transaction instance
        """
        self.transactions.append(transaction)
        self.transaction_hashes.append(transaction.tx_hash)

    def add_storage_proof(self, video_hash: str, miner_signature: str) -> None:
        """
        Record miner's proof of video storage/transcoding.
        
        Args:
            video_hash: IPFS CID of video
            miner_signature: Miner's cryptographic signature
        """
        self.video_proofs.append({
            'video_hash': video_hash,
            'miner_signature': miner_signature,
            'timestamp': CryptoUtils.timestamp_now()
        })

    def to_dict(self) -> Dict[str, Any]:
        """
        Convert block to dictionary for serialization/storage.
        
        Returns:
            Dictionary representation of block
        """
        return {
            'block_number': self.block_number,
            'block_hash': self.block_hash,
            'timestamp': self.timestamp,
            'miner_address': self.miner_address,
            'previous_hash': self.previous_hash,
            'transactions': [tx.to_dict() for tx in self.transactions],
            'transaction_hashes': self.transaction_hashes,
            'video_proofs': self.video_proofs,
            'proof_of_work': self.proof_of_work,
            'block_reward': self.block_reward.to_dict() if self.block_reward else None,
            'difficulty': self.difficulty,
            'nonce': self.nonce,
            'metadata': self.metadata
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Block':
        """
        Reconstruct block from dictionary.
        
        Args:
            data: Dictionary representation
            
        Returns:
            Block instance
        """
        data = data.copy()
        data.pop('block_hash', None)  # Remove computed hash
        
        # Reconstruct transactions
        if 'transactions' in data:
            data['transactions'] = [
                Transaction.from_dict(tx) 
                for tx in data['transactions']
            ]
        
        return Block(**data)

    def __repr__(self) -> str:
        return (
            f"Block(number={self.block_number}, "
            f"hash={self.block_hash[:16]}..., "
            f"txs={len(self.transactions)}, "
            f"miner={self.miner_address[:16]}...)"
        )
